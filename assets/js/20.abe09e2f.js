(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{225:function(t,e,r){"use strict";r.r(e);var a=r(28),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:"前端路由前世今生"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前端路由前世今生"}},[t._v("#")]),t._v(" 前端路由前世今生")]),t._v(" "),r("blockquote",[r("p",[r("strong",[t._v("路由")]),t._v("（"),r("strong",[t._v("routing")]),t._v("）就是通过互联的"),r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%AF%E7%B6%B2",target:"_blank",rel:"noopener noreferrer"}},[t._v("网络"),r("OutboundLink")],1),t._v("把"),r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF",target:"_blank",rel:"noopener noreferrer"}},[t._v("信息"),r("OutboundLink")],1),t._v("从源地址传输到目的地址的活动。路由发生在"),r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B",target:"_blank",rel:"noopener noreferrer"}},[t._v("OSI网络参考模型中"),r("OutboundLink")],1),t._v("的第三层即"),r("a",{attrs:{href:"https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%B1%82",target:"_blank",rel:"noopener noreferrer"}},[t._v("网络层"),r("OutboundLink")],1),t._v("。")])]),t._v(" "),r("p",[t._v("路由匹配到相应的 URL，然后由对应的函数决定返回这个 URL 什么资源，可以是一个 .html 文件，一个图片等等。")]),t._v(" "),r("h4",{attrs:{id:"后端路由与服务端渲染"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#后端路由与服务端渲染"}},[t._v("#")]),t._v(" 后端路由与服务端渲染")]),t._v(" "),r("p",[t._v("众所周知，在 web 的远古时代，网页通常是通过后端路由直出给客户端浏览器的。也就是网页的 HTML 一般是在后端服务器里通过模板引擎渲染好再交给前端的。至于一些其他的效果，是预先写在页面里的 jQuery、Bootstrap 等常见的前端框架去负责的。")]),t._v(" "),r("p",[t._v("在 web 后端，不管是什么语言的后端框架，都会有一个专门开辟出来的路由模块或者路由区域，用来匹配用户给出的URL地址，以及一些表单提交、ajax请求的地址。通常遇到无法匹配的路由，后端将会返回一个404状态码。这也是我们常说的404（Not Found）的由来。")]),t._v(" "),r("p",[t._v("用户通过URL访问到的页面，多数都是由后端进行"),r("strong",[t._v("路由匹配")]),t._v("之后返回的是一个‘完备的’"),r("strong",[t._v("静态")]),t._v("的页面。")]),t._v(" "),r("p",[t._v("服务端渲染( SSR )的好处有很多，比如对于 SEO 友好（因为他所有的数据内容，都已经在文件里面，不需要进一步生成），对安全性要求高的页面采用服务端渲染是更保险的，因为前端不做任何请求操作，只是展示服务端返回的文件。而在当时还没有 node.js 的年代，为了良好地构建前端页面，都是通过服务端语言对应的模板引擎来实现动态网页、页面结构的组织、组件的复用。实际上到如今，一门后端语言想要能实现自己的 web 功能，都需要有自己对应的模板引擎")]),t._v(" "),r("h4",{attrs:{id:"前端路由与前端渲染"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前端路由与前端渲染"}},[t._v("#")]),t._v(" 前端路由与前端渲染")]),t._v(" "),r("p",[t._v("前端渲染把渲染的任务交给了浏览器，通过客户端的算力来解决页面的构建，这个很大程度上缓解了服务端的压力。而且配合"),r("strong",[t._v("前端路由")]),t._v("，无缝的"),r("strong",[t._v("页面切换体验")]),t._v("自然是对用户友好的。前端路由进行切换是不会引起浏览器刷新的，也就是说，不会去对服务器端发起请求。")]),t._v(" "),r("p",[t._v("随着 ajax 的流行，异步数据请求交互运行在不刷新浏览器的情况下进行。而异步交互体验的更高级版本就是 SPA —— 单页应用。单页应用不仅仅是在页面交互是无刷新的，连页面跳转都是无刷新的，为了实现单页应用，所以就有了前端路由。")]),t._v(" "),r("h4",{attrs:{id:"hash模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#hash模式"}},[t._v("#")]),t._v(" Hash模式")]),t._v(" "),r("ul",[r("li",[r("p",[t._v("url 中 hash 值的变化并不会重新加载页面，因为 hash 是用来指导浏览器行为的，对服务端是无用的，所以不会包括在 http 请求中。")])]),t._v(" "),r("li",[r("p",[t._v("hash 值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制 hash 的切换")])]),t._v(" "),r("li",[r("p",[t._v("我们可以通过 hashchange 事件，监听到 hash 值的变化，从而响应不同路径的逻辑处理。")])])]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('window.addEventListener("hashchange", funcRef, false)\n')])])]),r("p",[t._v("我们可以在 hashchange 函数里面进行相应的页面更新，但不会去重新请求页面，同时呢，也在 history 里增加了一条访问记录，用户也仍然可以通过前进后退键实现 UI 的切换。这样，不管是我们在浏览器的地址栏输入，或者是页面里通过 router 的 api 进行的跳转，都是一样的跳转逻辑。所以这个模式是不需要后端配置其他逻辑的，只要给前端返回 https://www.yuque.com 对应的 html，剩下具体是哪个页面，就由前端路由去解析路由配置，并加载相应页面。")]),t._v(" "),r("h4",{attrs:{id:"history模式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#history模式"}},[t._v("#")]),t._v(" History模式")]),t._v(" "),r("p",[t._v("HTML5 提出了 history 的API。")]),t._v(" "),r("p",[t._v("相同之处是两个 API 都会操作浏览器的历史记录，而"),r("strong",[t._v("不会引起页面的刷新")]),t._v("。")]),t._v(" "),r("p",[t._v("不同之处在于，pushState 会增加一条新的历史记录，而 replaceState 则会替换当前的历史记录。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("history.pushState(stateObject, title, url)\nhistory.replaceState(stateObject, title, url)\n")])])]),r("p",[t._v("此时，就会出现一个问题，由于浏览器的路由跳转是交给前端路由控制了，所以后端将不处理404的错误界面，因为服务端会对所有路径都返回那一个HTML模板文件。")]),t._v(" "),r("div",{staticClass:"language-nginx extra-class"},[r("pre",{pre:!0,attrs:{class:"language-nginx"}},[r("code",[r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("location")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try_files")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$uri")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token variable"}},[t._v("$uri")]),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),t._v(" "),r("span",{pre:!0,attrs:{class:"token operator"}},[t._v("/")]),r("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("index")]),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("html"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),r("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),r("p",[t._v("这种方式无法返回404的页面的，前端可以定义在路由404情况下返回特定的页面：")]),t._v(" "),r("div",{staticClass:"language-vue extra-class"},[r("pre",{pre:!0,attrs:{class:"language-vue"}},[r("code",[t._v("const router = new VueRouter({\n    mode: 'history',\n    routes: [{\n        path: '*', component: NotFoundPage\n    }]\n});\n")])])]),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("// https://blog.csdn.net/weixin_37861326/article/details/82383465\nimport Vue from 'vue'\nimport Router from 'vue-router'\nVue.use(Router)\n// 404\nimport Errorinfo from '@/components/error404'\n \nconst router = new Router({\n  routes: [\n    // 404page\n    {\n      path: '/errorinfo',\n      name: 'Errorinfo',\n      component: Errorinfo\n    }\n  ],\n  scrollBehavior(to, from, savedPosition) {\n    return {\n      x: 0,\n      y: 0\n    }\n  },\n  history: true\n})\nrouter.beforeEach((to, from, next) => {\n  if (to.matched.length === 0) { \n    from.name ? next({\n      name: from.name\n    }) : next('/errorinfo'); \n  } else {\n    next(); //如果匹配到正确跳转\n  }\n});\nexport default router;\n")])])]),r("p",[r("strong",[t._v("Reference：")])]),t._v(" "),r("p",[r("a",{attrs:{href:"https://github.com/chiwent/blog/issues/12",target:"_blank",rel:"noopener noreferrer"}},[t._v("谈谈前端路由"),r("OutboundLink")],1)]),t._v(" "),r("p",[r("a",{attrs:{href:"https://www.yuque.com/fekl/fe/dbeyky",target:"_blank",rel:"noopener noreferrer"}},[t._v("Router的前世今生"),r("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);