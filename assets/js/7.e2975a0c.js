(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{210:function(t,a,s){t.exports=s.p+"assets/img/stack1.3e5f85e1.png"},211:function(t,a,s){t.exports=s.p+"assets/img/stack2.b8a68e6c.png"},253:function(t,a,s){"use strict";s.r(a);var e=s(28),r=Object(e.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"javascript-执行机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-执行机制"}},[t._v("#")]),t._v(" Javascript 执行机制")]),t._v(" "),e("h4",{attrs:{id:"作用域（scope）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#作用域（scope）"}},[t._v("#")]),t._v(" 作用域（scope）")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期")])])]),t._v(" "),e("h4",{attrs:{id:"变量提升所带来的问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#变量提升所带来的问题"}},[t._v("#")]),t._v(" 变量提升所带来的问题")]),t._v(" "),e("ul",[e("li",[t._v("变量容易在不被察觉的情况下被覆盖掉")]),t._v(" "),e("li",[t._v("本应销毁的变量没有被销毁")])]),t._v(" "),e("h4",{attrs:{id:"es6-是如何解决变量提升带来的缺陷"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#es6-是如何解决变量提升带来的缺陷"}},[t._v("#")]),t._v(" ES6 是如何解决变量提升带来的缺陷")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function letTest() {\n  let x = 1;\n  if (true) {\n    let x = 2;  // 不同的变量\n    console.log(x);  // 2\n  }\n  console.log(x);  // 1\n}\n")])])]),e("p",[t._v("JavaScript 引擎并不会把 if 块中通过 let 声明的变量存放到变量环境中，这也就意味着在 if 块通过 let 声明的关键字，并不会提升到全函数可见。所以在 if 块之内打印出来的值是 2，跳出语块之后，打印出来的值就是 1 了。**")]),t._v(" "),e("h4",{attrs:{id:"javascript-是如何支持块级作用域的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#javascript-是如何支持块级作用域的"}},[t._v("#")]),t._v(" JavaScript 是如何支持块级作用域的")]),t._v(" "),e("p",[t._v("ES 可以通过使用 let 或者 const 关键字来实现块级作用域。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function foo(){\n    var a = 1\n    let b = 2\n    {\n      let b = 3\n      var c = 4\n      let d = 5\n      console.log(a)\n      console.log(b)\n    }\n    console.log(b) \n    console.log(c)\n    console.log(d)\n}   \nfoo()\n")])])]),e("ol",[e("li",[e("strong",[t._v("编译并创建执行上下文")])])]),t._v(" "),e("p",[e("img",{attrs:{src:s(210),alt:"process"}})]),t._v(" "),e("ul",[e("li",[t._v("函数内部通过 var 声明的变量，在编译阶段全都被存放到"),e("strong",[t._v("变量环境")]),t._v("里面了。")]),t._v(" "),e("li",[t._v("通过 let 声明的变量，在编译阶段会被存放到**词法环境（Lexical Environment）**中。")]),t._v(" "),e("li",[t._v("在函数的作用域内部，通过 let 声明的变量并没有被存放到词法环境中")])]),t._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[e("strong",[t._v("继续执行代码")])])]),t._v(" "),e("p",[e("img",{attrs:{src:s(211),alt:"process"}})]),t._v(" "),e("p",[t._v("当进入函数的作用域块时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。")]),t._v(" "),e("p",[t._v("其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。需要注意下，我这里所讲的变量是指通过 let 或者 const 声明的变量。")]),t._v(" "),e("h4",{attrs:{id:"词法作用域"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#词法作用域"}},[t._v("#")]),t._v(" 词法作用域")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。")])])]),t._v(" "),e("h4",{attrs:{id:"闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包"}},[t._v("#")]),t._v(" 闭包")]),t._v(" "),e("blockquote",[e("p",[e("strong",[t._v("根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。")])])]),t._v(" "),e("h4",{attrs:{id:"闭包是怎么回收的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包是怎么回收的"}},[t._v("#")]),t._v(" 闭包是怎么回收的")]),t._v(" "),e("p",[t._v("如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。")]),t._v(" "),e("p",[t._v("如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。")]),t._v(" "),e("p",[e("strong",[t._v("Rerfence:")])]),t._v(" "),e("p",[e("a",{attrs:{href:"https://time.geekbang.org/column/intro/100033601",target:"_blank",rel:"noopener noreferrer"}},[t._v("浏览器工作原理与实践"),e("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=r.exports}}]);