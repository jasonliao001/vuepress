(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{212:function(v,t,r){v.exports=r.p+"assets/img/loop.b6d1b4df.png"},213:function(v,t,r){v.exports=r.p+"assets/img/micro.d35b5c66.png"},251:function(v,t,r){"use strict";r.r(t);var _=r(28),a=Object(_.a)({},(function(){var v=this,t=v.$createElement,_=v._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"页面循环系统"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#页面循环系统"}},[v._v("#")]),v._v(" 页面循环系统")]),v._v(" "),_("blockquote",[_("p",[v._v("每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是消息队列和事件循环系统。")])]),v._v(" "),_("p",[_("img",{attrs:{src:r(212),alt:"process"}})]),v._v(" "),_("p",[_("strong",[v._v("渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息")]),v._v("，接收到消息之后，会将这些消息组装成任务发送给渲染主线程，")]),v._v(" "),_("h4",{attrs:{id:"消息队列中的任务类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#消息队列中的任务类型"}},[v._v("#")]),v._v(" 消息队列中的任务类型")]),v._v(" "),_("p",[_("a",{attrs:{href:"https://cs.chromium.org/chromium/src/third_party/blink/public/platform/task_type.h",target:"_blank",rel:"noopener noreferrer"}},[v._v("任务类型"),_("OutboundLink")],1)]),v._v(" "),_("h4",{attrs:{id:"页面使用单线程的缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#页面使用单线程的缺点"}},[v._v("#")]),v._v(" 页面使用单线程的缺点")]),v._v(" "),_("ul",[_("li",[_("p",[_("strong",[v._v("如何处理高优先级的任务。")])]),v._v(" "),_("p",[v._v("权衡"),_("strong",[v._v("效率")]),v._v("和"),_("strong",[v._v("实时性")]),v._v("?")]),v._v(" "),_("p",[v._v("通常我们把消息队列中的任务称为"),_("strong",[v._v("宏任务")]),v._v("，每个宏任务中都包含了一个"),_("strong",[v._v("微任务队列")]),v._v("，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。")]),v._v(" "),_("p",[v._v("等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。")])])]),v._v(" "),_("h4",{attrs:{id:"宏任务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#宏任务"}},[v._v("#")]),v._v(" 宏任务")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("渲染事件（如解析 DOM、计算布局、绘制）；")])]),v._v(" "),_("li",[_("p",[v._v("用户交互事件（如鼠标点击、滚动页面、放大缩小等）；")])]),v._v(" "),_("li",[_("p",[v._v("JavaScript 脚本执行事件；")])]),v._v(" "),_("li",[_("p",[v._v("网络请求完成、文件读写完成事件。")]),v._v(" "),_("p",[v._v("为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中的任务称为"),_("strong",[v._v("宏任务")]),v._v("。")])])]),v._v(" "),_("p",[v._v("在"),_("a",{attrs:{href:"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model",target:"_blank",rel:"noopener noreferrer"}},[v._v("WHATWG 规范"),_("OutboundLink")],1),v._v("中是怎么定义事件循环机制?")]),v._v(" "),_("ul",[_("li",[v._v("先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；")]),v._v(" "),_("li",[v._v("然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；")]),v._v(" "),_("li",[v._v("当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；")]),v._v(" "),_("li",[v._v("最后统计执行完成的时长等信息。")])]),v._v(" "),_("p",[v._v("宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了.")]),v._v(" "),_("h4",{attrs:{id:"微任务"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#微任务"}},[v._v("#")]),v._v(" 微任务")]),v._v(" "),_("p",[v._v("异步回调?")]),v._v(" "),_("p",[_("strong",[v._v("第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数")]),v._v("。")]),v._v(" "),_("p",[_("strong",[v._v("第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。")])]),v._v(" "),_("p",[v._v("微任务到底是什么呢?")]),v._v(" "),_("p",[_("strong",[v._v("微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。")])]),v._v(" "),_("p",[v._v("微任务系统是怎么运转起来的?")]),v._v(" "),_("p",[v._v("当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个"),_("strong",[v._v("微任务队列")]),v._v("。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的。")]),v._v(" "),_("p",[v._v("微任务产生的时机和执行微任务队列的时机？")]),v._v(" "),_("p",[v._v("产生微任务有两种方式？")]),v._v(" "),_("p",[v._v("第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。")]),v._v(" "),_("p",[v._v("第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。")]),v._v(" "),_("p",[v._v("执行微任务队列的时机？")]),v._v(" "),_("p",[v._v("在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。"),_("strong",[v._v("WHATWG 把执行微任务的时间点称为检查点")])]),v._v(" "),_("p",[v._v("如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。")]),v._v(" "),_("p",[_("img",{attrs:{src:r(213),alt:"process"}})]),v._v(" "),_("p",[v._v("该示意图是在执行一个 ParseHTML 的宏任务，在执行过程中，遇到了 JavaScript 脚本，那么就暂停解析流程，进入到 JavaScript 的执行环境。从图中可以看到，全局上下文中包含了微任务列表。")]),v._v(" "),_("p",[v._v("在 JavaScript 脚本的后续执行过程中，分别通过 Promise 和 removeChild 创建了两个微任务，并被添加到微任务列表中。接着 JavaScript 执行结束，准备退出全局执行上下文，这时候就到了检查点了，JavaScript 引擎会检查微任务列表，发现微任务列表中有微任务，那么接下来，依次执行这两个微任务。等微任务队列清空之后，就退出全局执行上下文。")]),v._v(" "),_("p",[v._v("以上就是微任务的工作流程，从上面分析我们可以得出如下几个"),_("strong",[v._v("结论")]),v._v("：")]),v._v(" "),_("ul",[_("li",[v._v("微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。")]),v._v(" "),_("li",[v._v("微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。")]),v._v(" "),_("li",[v._v("在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。")])]),v._v(" "),_("p",[_("strong",[v._v("Rerfence:")])]),v._v(" "),_("p",[_("a",{attrs:{href:"https://time.geekbang.org/column/intro/100033601",target:"_blank",rel:"noopener noreferrer"}},[v._v("浏览器工作原理与实践"),_("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);