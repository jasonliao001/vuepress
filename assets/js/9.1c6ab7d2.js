(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{207:function(t,v,_){t.exports=_.p+"assets/img/render.a747645d.png"},259:function(t,v,_){"use strict";_.r(v);var r=_(28),s=Object(r.a)({},(function(){var t=this,v=t.$createElement,r=t._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:"渲染流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#渲染流程"}},[t._v("#")]),t._v(" 渲染流程")]),t._v(" "),r("h4",{attrs:{id:"构建-dom-树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#构建-dom-树"}},[t._v("#")]),t._v(" "),r("strong",[t._v("构建")]),t._v(" "),r("strong",[t._v("DOM")]),t._v(" "),r("strong",[t._v("树")])]),t._v(" "),r("blockquote",[r("p",[t._v("因为浏览器无法直接理解和使用 HTML，所以需要将HTML 转换为浏览器能够理解的结构——DOM 。")])]),t._v(" "),r("p",[t._v("DOM 树的"),r("strong",[t._v("输入内容")]),t._v("是一个非常简单的 HTML 文件,经由 HTML 解析器"),r("strong",[t._v("解析")]),t._v(","),r("strong",[t._v("输出")]),t._v("树状结构的 DOM")]),t._v(" "),r("h4",{attrs:{id:"样式计算-recalculate-style"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#样式计算-recalculate-style"}},[t._v("#")]),t._v(" 样式计算(Recalculate Style)")]),t._v(" "),r("p",[r("strong",[t._v("1.")]),t._v(" 把 CSS 转换为浏览器能够理解的结构")]),t._v(" "),r("p",[t._v("渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构—— styleSheets。 "),r("code",[t._v("document.styleSheets")])]),t._v(" "),r("p",[r("strong",[t._v("2.")]),t._v(" "),r("strong",[t._v("转换样式表中的属性值，使其标准化")])]),t._v(" "),r("p",[r("strong",[t._v("3.")]),t._v(" "),r("strong",[t._v("计算出")]),t._v(" "),r("strong",[t._v("DOM")]),t._v(" "),r("strong",[t._v("树中每个节点的具体样式")])]),t._v(" "),r("h4",{attrs:{id:"布局阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#布局阶段"}},[t._v("#")]),t._v(" "),r("strong",[t._v("布局阶段")])]),t._v(" "),r("blockquote",[r("p",[t._v("计算出 DOM 树中可见元素的几何位 置，我们把这个计算过程叫做布局。")])]),t._v(" "),r("p",[r("strong",[t._v("1.")]),t._v(" "),r("strong",[t._v("创建布局树")])]),t._v(" "),r("p",[r("strong",[t._v("2.")]),t._v(" "),r("strong",[t._v("布局计算")])]),t._v(" "),r("h4",{attrs:{id:"分层"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分层"}},[t._v("#")]),t._v(" "),r("strong",[t._v("分层")])]),t._v(" "),r("blockquote",[r("p",[r("strong",[t._v("渲染引擎还需要为特定的节点生成专用的 图层，并生成一棵对应的图层树")]),t._v("(LayerTree)")])]),t._v(" "),r("h4",{attrs:{id:"图层绘制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#图层绘制"}},[t._v("#")]),t._v(" "),r("strong",[t._v("图层绘制")])]),t._v(" "),r("blockquote",[r("p",[t._v("在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制")])]),t._v(" "),r("h4",{attrs:{id:"栅格化-raster-操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栅格化-raster-操作"}},[t._v("#")]),t._v(" "),r("strong",[t._v("栅格化(raster)操作")])]),t._v(" "),r("p",[r("strong",[t._v("合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执 行的。所谓栅格化，是指将图块转换为位图")]),t._v("。而图块是栅格化执行的最小单位。渲染进程维 护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的")]),t._v(" "),r("p",[r("img",{attrs:{src:_(207),alt:"process"}})]),t._v(" "),r("p",[r("strong",[t._v("一个完整的渲染流程大致可总结为如下:")])]),t._v(" "),r("ol",[r("li",[r("p",[t._v("渲染进程将 HTML 内容转换为能够读懂的"),r("strong",[t._v("DOM 树")]),t._v("结构。")])]),t._v(" "),r("li",[r("p",[t._v("渲染引擎将 CSS 样式表转化为浏览器可以理解的"),r("strong",[t._v("styleSheets")]),t._v("，计算出 DOM 节点的")]),t._v(" "),r("p",[t._v("样式。")])]),t._v(" "),r("li",[r("p",[t._v("创建"),r("strong",[t._v("布局树")]),t._v("，并计算元素的布局信息。")])]),t._v(" "),r("li",[r("p",[t._v("对布局树进行分层，并生成"),r("strong",[t._v("分层树")]),t._v("。")])]),t._v(" "),r("li",[r("p",[t._v("为每个图层生成"),r("strong",[t._v("绘制列表")]),t._v("，并将其提交到合成线程。")])]),t._v(" "),r("li",[r("p",[t._v("合成线程将图层分成"),r("strong",[t._v("图块")]),t._v("，并在"),r("strong",[t._v("光栅化线程池")]),t._v("中将图块转换成位图。")])]),t._v(" "),r("li",[r("p",[t._v("合成线程发送绘制图块命令"),r("strong",[t._v("DrawQuad")]),t._v("给浏览器进程。")])]),t._v(" "),r("li",[r("p",[t._v("浏览器进程根据 DrawQuad 消息"),r("strong",[t._v("生成页面")]),t._v("，并"),r("strong",[t._v("显示")]),t._v("到显示器上。")])])]),t._v(" "),r("h4",{attrs:{id:"重排-重绘和合成"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#重排-重绘和合成"}},[t._v("#")]),t._v(" "),r("strong",[t._v("重排 ,重绘和合成")])]),t._v(" "),r("p",[r("strong",[t._v("1.")]),t._v(" "),r("strong",[t._v("更新了元素的几何属性(重排)")])]),t._v(" "),r("p",[t._v("你通过 JavaScript 或者 CSS 修改元素的几何位置属性,浏览器会触发重新布局,重排需要更新完整的渲染流水线.")]),t._v(" "),r("p",[r("strong",[t._v("2.")]),t._v(" "),r("strong",[t._v("更新元素的绘制属性(重绘)")])]),t._v(" "),r("p",[t._v("重绘省去了布局和分层阶段，所以执行效率会比重排操作要高 一些。")]),t._v(" "),r("p",[r("strong",[t._v("3.")]),t._v(" "),r("strong",[t._v("直接合成阶段")])]),t._v(" "),r("p",[t._v("渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做"),r("strong",[t._v("合成")])]),t._v(" "),r("p",[t._v("CSS 的 transform 来实现动画效果,避开了布局和绘制两个子阶段，大大提升绘制效率。")]),t._v(" "),r("p",[r("strong",[t._v("Rerfence:")])]),t._v(" "),r("p",[r("a",{attrs:{href:"https://time.geekbang.org/column/intro/100033601",target:"_blank",rel:"noopener noreferrer"}},[t._v("浏览器工作原理与实践"),r("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=s.exports}}]);