<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>EventTarget 接口 | bxliao</title>
    <meta name="description" content="记录，分享，技术成长">
    <meta name="generator" content="VuePress 1.3.1">
    
    
    <link rel="preload" href="/vuepress/assets/css/0.styles.379a8785.css" as="style"><link rel="preload" href="/vuepress/assets/js/app.0ad50b13.js" as="script"><link rel="preload" href="/vuepress/assets/js/2.7cf59c07.js" as="script"><link rel="preload" href="/vuepress/assets/js/18.e66fe3ad.js" as="script"><link rel="prefetch" href="/vuepress/assets/js/10.7051dd6d.js"><link rel="prefetch" href="/vuepress/assets/js/11.b78552fe.js"><link rel="prefetch" href="/vuepress/assets/js/12.a3f37b4e.js"><link rel="prefetch" href="/vuepress/assets/js/13.48c60c84.js"><link rel="prefetch" href="/vuepress/assets/js/14.9e1e07a4.js"><link rel="prefetch" href="/vuepress/assets/js/15.f6563af8.js"><link rel="prefetch" href="/vuepress/assets/js/16.885f059c.js"><link rel="prefetch" href="/vuepress/assets/js/17.87c57e56.js"><link rel="prefetch" href="/vuepress/assets/js/19.2b4db5f2.js"><link rel="prefetch" href="/vuepress/assets/js/20.abe09e2f.js"><link rel="prefetch" href="/vuepress/assets/js/21.3b91fe73.js"><link rel="prefetch" href="/vuepress/assets/js/22.af4af1a8.js"><link rel="prefetch" href="/vuepress/assets/js/23.1fcfe0b9.js"><link rel="prefetch" href="/vuepress/assets/js/24.d7c1f4a8.js"><link rel="prefetch" href="/vuepress/assets/js/25.5121739d.js"><link rel="prefetch" href="/vuepress/assets/js/26.2818839b.js"><link rel="prefetch" href="/vuepress/assets/js/27.038138bf.js"><link rel="prefetch" href="/vuepress/assets/js/28.e093f550.js"><link rel="prefetch" href="/vuepress/assets/js/29.a161cf3a.js"><link rel="prefetch" href="/vuepress/assets/js/3.18ebda36.js"><link rel="prefetch" href="/vuepress/assets/js/30.98045800.js"><link rel="prefetch" href="/vuepress/assets/js/31.0bea32d9.js"><link rel="prefetch" href="/vuepress/assets/js/32.9a1237d0.js"><link rel="prefetch" href="/vuepress/assets/js/33.ddac3cbe.js"><link rel="prefetch" href="/vuepress/assets/js/34.1a746ae0.js"><link rel="prefetch" href="/vuepress/assets/js/35.6a085065.js"><link rel="prefetch" href="/vuepress/assets/js/36.b095d317.js"><link rel="prefetch" href="/vuepress/assets/js/37.e495042e.js"><link rel="prefetch" href="/vuepress/assets/js/38.741b638e.js"><link rel="prefetch" href="/vuepress/assets/js/39.f5a3030f.js"><link rel="prefetch" href="/vuepress/assets/js/4.bd5ca72f.js"><link rel="prefetch" href="/vuepress/assets/js/40.3d6f9139.js"><link rel="prefetch" href="/vuepress/assets/js/41.df7b5653.js"><link rel="prefetch" href="/vuepress/assets/js/42.27050bb2.js"><link rel="prefetch" href="/vuepress/assets/js/43.b57cfb1a.js"><link rel="prefetch" href="/vuepress/assets/js/44.c3831e0d.js"><link rel="prefetch" href="/vuepress/assets/js/45.2584058d.js"><link rel="prefetch" href="/vuepress/assets/js/46.e3f413fd.js"><link rel="prefetch" href="/vuepress/assets/js/47.80a9ca21.js"><link rel="prefetch" href="/vuepress/assets/js/48.62d46beb.js"><link rel="prefetch" href="/vuepress/assets/js/49.11254305.js"><link rel="prefetch" href="/vuepress/assets/js/5.22c734f0.js"><link rel="prefetch" href="/vuepress/assets/js/50.f4596a9b.js"><link rel="prefetch" href="/vuepress/assets/js/51.f1332ae8.js"><link rel="prefetch" href="/vuepress/assets/js/52.a9c597c8.js"><link rel="prefetch" href="/vuepress/assets/js/53.46cf4878.js"><link rel="prefetch" href="/vuepress/assets/js/54.5fb2dd96.js"><link rel="prefetch" href="/vuepress/assets/js/55.3f528df2.js"><link rel="prefetch" href="/vuepress/assets/js/56.5b4f961b.js"><link rel="prefetch" href="/vuepress/assets/js/57.a9ff1efc.js"><link rel="prefetch" href="/vuepress/assets/js/58.6233a362.js"><link rel="prefetch" href="/vuepress/assets/js/59.72925434.js"><link rel="prefetch" href="/vuepress/assets/js/6.a7451eec.js"><link rel="prefetch" href="/vuepress/assets/js/60.60f12184.js"><link rel="prefetch" href="/vuepress/assets/js/61.b887e966.js"><link rel="prefetch" href="/vuepress/assets/js/62.70d1255f.js"><link rel="prefetch" href="/vuepress/assets/js/7.e2975a0c.js"><link rel="prefetch" href="/vuepress/assets/js/8.69ee3e3f.js"><link rel="prefetch" href="/vuepress/assets/js/9.1c6ab7d2.js">
    <link rel="stylesheet" href="/vuepress/assets/css/0.styles.379a8785.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vuepress/" class="home-link router-link-active"><!----> <span class="site-name">bxliao</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vuepress/SiteNav/recommend.html" class="nav-link">
  网址导航
</a></div><div class="nav-item"><a href="/vuepress/CheckList/Javascript/grammar.html" class="nav-link">
  前端大全
</a></div><div class="nav-item"><a href="/vuepress/Node/basic.html" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/vuepress/Computer/Linux.html" class="nav-link">
  计算机知识
</a></div><div class="nav-item"><a href="/vuepress/Algorithm/DataStruct.html" class="nav-link">
  设计模式与算法
</a></div><div class="nav-item"><a href="/vuepress/About.html" class="nav-link">
  关于我
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vuepress/SiteNav/recommend.html" class="nav-link">
  网址导航
</a></div><div class="nav-item"><a href="/vuepress/CheckList/Javascript/grammar.html" class="nav-link">
  前端大全
</a></div><div class="nav-item"><a href="/vuepress/Node/basic.html" class="nav-link">
  Node
</a></div><div class="nav-item"><a href="/vuepress/Computer/Linux.html" class="nav-link">
  计算机知识
</a></div><div class="nav-item"><a href="/vuepress/Algorithm/DataStruct.html" class="nav-link">
  设计模式与算法
</a></div><div class="nav-item"><a href="/vuepress/About.html" class="nav-link">
  关于我
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>前端基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>Browser</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/vuepress/CheckList/Browser/chrome.html" class="sidebar-link">Chrome发展历程</a></li><li><a href="/vuepress/CheckList/Browser/router.html" class="sidebar-link">路由变迁</a></li><li><a href="/vuepress/CheckList/Browser/chrome01.html" class="sidebar-link">数据交流</a></li><li><a href="/vuepress/CheckList/Browser/chrome02.html" class="sidebar-link">渲染流程</a></li><li><a href="/vuepress/CheckList/Browser/chrome03.html" class="sidebar-link">V8 工作原理</a></li><li><a href="/vuepress/CheckList/Browser/chrome04.html" class="sidebar-link">Javascript 执行机制</a></li><li><a href="/vuepress/CheckList/Browser/chrome05.html" class="sidebar-link">页面循环系统</a></li><li><a href="/vuepress/CheckList/Browser/ajax.html" class="sidebar-link">网络请求</a></li><li><a href="/vuepress/CheckList/Browser/window.html" class="sidebar-link">Window</a></li><li><a href="/vuepress/CheckList/Browser/dom.html" class="sidebar-link">Dom</a></li><li><a href="/vuepress/CheckList/Browser/event.html" class="active sidebar-link">Event</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vuepress/CheckList/Browser/event.html#eventtarget-接口" class="sidebar-link">EventTarget 接口</a></li><li class="sidebar-sub-header"><a href="/vuepress/CheckList/Browser/event.html#事件的传播" class="sidebar-link">事件的传播</a></li><li class="sidebar-sub-header"><a href="/vuepress/CheckList/Browser/event.html#event-对象概述" class="sidebar-link">Event 对象概述</a></li><li class="sidebar-sub-header"><a href="/vuepress/CheckList/Browser/event.html#customevent-接口" class="sidebar-link">CustomEvent 接口</a></li><li class="sidebar-sub-header"><a href="/vuepress/CheckList/Browser/event.html#事件种类" class="sidebar-link">事件种类</a></li><li class="sidebar-sub-header"><a href="/vuepress/CheckList/Browser/event.html#键盘事件" class="sidebar-link">键盘事件</a></li><li class="sidebar-sub-header"><a href="/vuepress/CheckList/Browser/event.html#拖拉事件" class="sidebar-link">拖拉事件</a></li><li class="sidebar-sub-header"><a href="/vuepress/CheckList/Browser/event.html#触摸操作" class="sidebar-link">触摸操作</a></li><li class="sidebar-sub-header"><a href="/vuepress/CheckList/Browser/event.html#session-历史事件" class="sidebar-link">session 历史事件</a></li><li class="sidebar-sub-header"><a href="/vuepress/CheckList/Browser/event.html#剪贴板事件" class="sidebar-link">剪贴板事件</a></li><li class="sidebar-sub-header"><a href="/vuepress/CheckList/Browser/event.html#焦点事件" class="sidebar-link">焦点事件</a></li></ul></li><li><a href="/vuepress/CheckList/Browser/other.html" class="sidebar-link">其他</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端规范</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端框架</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="eventtarget-接口"><a href="#eventtarget-接口" class="header-anchor">#</a> EventTarget 接口</h2> <ul><li><code>addEventListener</code>：绑定事件的监听函数</li> <li><code>removeEventListener</code>：移除事件的监听函数</li> <li><code>dispatchEvent</code>：触发事件</li></ul> <h3 id="eventtarget-addeventlistener"><a href="#eventtarget-addeventlistener" class="header-anchor">#</a> EventTarget.addEventListener()</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code>target<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> listener<span class="token punctuation">[</span><span class="token punctuation">,</span> useCapture<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><code>type</code>：事件名称，大小写敏感。</li> <li><code>listener</code>：监听函数。事件发生时，会调用该监听函数。</li> <li><code>useCapture</code>：布尔值，表示监听函数是否在捕获阶段（capture）触发</li></ul> <p>第二个参数除了监听函数，还可以是一个具有<code>handleEvent</code>方法的对象。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>buttonElement<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">handleEvent</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>第三个参数除了布尔值<code>useCapture</code>，还可以是一个属性配置对象。</p> <ul><li><code>capture</code>：布尔值，表示该事件是否在<code>捕获阶段</code>触发监听函数。</li> <li><code>once</code>：布尔值，表示监听函数是否只触发一次，然后就自动移除。</li> <li><code>passive</code>：布尔值，表示监听函数不会调用事件的<code>preventDefault</code>方法。如果监听函数调用了，浏览器将忽略这个要求，并在监控台输出一行警告。</li></ul> <h3 id="eventtarget-dispatchevent"><a href="#eventtarget-dispatchevent" class="header-anchor">#</a> EventTarget.dispatchEvent()</h3> <p><code>EventTarget.dispatchEvent</code>方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了<code>Event.preventDefault()</code>，则返回值为<code>false</code>，否则为<code>true</code>。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>target<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span>
</code></pre></div><h2 id="事件的传播"><a href="#事件的传播" class="header-anchor">#</a> 事件的传播</h2> <ul><li><strong>第一阶段</strong>：从<code>window</code>对象传导到目标节点（上层传到底层），称为“捕获阶段”（capture phase）。</li> <li><strong>第二阶段</strong>：在目标节点上触发，称为“目标阶段”（target phase）。</li> <li><strong>第三阶段</strong>：从目标节点传导回<code>window</code>对象（从底层传回上层），称为“冒泡阶段”（bubbling phase）。</li></ul> <h3 id="事件的代理"><a href="#事件的代理" class="header-anchor">#</a> 事件的代理</h3> <p>由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> ul <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'ul'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ul<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>tagName<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'li'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// some code</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>如果希望事件到某个节点为止，不再传播，可以使用事件对象的<code>stopPropagation</code>方法。</p> <div class="language- extra-class"><pre class="language-text"><code>// 事件传播到 p 元素后，就不再向下传播了
p.addEventListener('click', function (event) {
  event.stopPropagation();
}, true);

// 事件冒泡到 p 元素后，就不再向上冒泡了
p.addEventListener('click', function (event) {
  event.stopPropagation();
}, false)
</code></pre></div><p><strong>如果想要彻底阻止这个事件的传播，不再触发后面所有<code>click</code>的监听函数，可以使用<code>stopImmediatePropagation</code>方法。</strong></p> <h2 id="event-对象概述"><a href="#event-对象概述" class="header-anchor">#</a> Event 对象概述</h2> <p>事件发生以后，会产生一个事件对象，作为参数传给监听函数。浏览器原生提供一个<code>Event</code>对象，所有的事件都是这个对象的实例，或者说继承了<code>Event.prototype</code>对象。</p> <div class="language- extra-class"><pre class="language-text"><code>event = new Event(type, options);
</code></pre></div><ul><li><code>bubbles</code>：布尔值，可选，默认为<code>false</code>，表示事件对象是否冒泡。</li> <li><code>cancelable</code>：布尔值，可选，默认为<code>false</code>，表示事件是否可以被取消，即能否用<code>Event.preventDefault()</code>取消这个事件。一旦事件被取消，就好像从来没有发生过，不会触发浏览器对该事件的默认行为。</li></ul> <h4 id="event-bubbles，event-eventphase"><a href="#event-bubbles，event-eventphase" class="header-anchor">#</a> Event.bubbles，Event.eventPhase</h4> <p><code>Event.bubbles</code>属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，一般用来了解 Event 实例是否可以冒泡。前面说过，除非显式声明，<code>Event</code>构造函数生成的事件，默认是不冒泡的。</p> <p><code>Event.eventPhase</code>属性返回一个整数常量，表示事件目前所处的阶段。该属性只读。</p> <ul><li>0，事件目前没有发生。</li> <li>1，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。</li> <li>2，事件到达目标节点，即<code>Event.target</code>属性指向的那个节点。</li> <li>3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。</li></ul> <h4 id="event-cancelable，event-cancelbubble，event-defaultprevented"><a href="#event-cancelable，event-cancelbubble，event-defaultprevented" class="header-anchor">#</a> Event.cancelable，Event.cancelBubble，event.defaultPrevented</h4> <p><code>Event.cancelable</code>属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，一般用来了解 Event 实例的特性。</p> <p><code>Event.cancelBubble</code>属性是一个布尔值，如果设为<code>true</code>，相当于执行<code>Event.stopPropagation()</code>，可以阻止事件的传播。</p> <p><code>Event.defaultPrevented</code>属性返回一个布尔值，表示该事件是否调用过<code>Event.preventDefault</code>方法。该属性只读。</p> <h4 id="event-currenttarget，event-target"><a href="#event-currenttarget，event-target" class="header-anchor">#</a> Event.currentTarget，Event.target</h4> <p><code>Event.currentTarget</code>属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点。</p> <p><code>Event.target</code>属性返回原始触发事件的那个节点，即事件最初发生的节点。事件传播过程中，不同节点的监听函数内部的<code>Event.target</code>与<code>Event.currentTarget</code>属性的值是不一样的，前者总是不变的，后者则是指向监听函数所在的那个节点对象。</p> <h4 id="event-istrusted"><a href="#event-istrusted" class="header-anchor">#</a> Event.isTrusted</h4> <p><code>Event.isTrusted</code>属性返回一个布尔值，表示该事件是否由真实的用户行为产生。比如，用户点击链接会产生一个<code>click</code>事件，该事件是用户产生的；<code>Event</code>构造函数生成的事件，则是脚本产生的。</p> <h4 id="event-preventdefault"><a href="#event-preventdefault" class="header-anchor">#</a> Event.preventDefault()</h4> <p><code>Event.preventDefault</code>方法取消浏览器对当前事件的默认行为。比如点击链接后，浏览器默认会跳转到另一个页面，使用这个方法以后，就不会跳转了；再比如，按一下空格键，页面向下滚动一段距离，使用这个方法以后也不会滚动了。该方法生效的前提是，事件对象的<code>cancelable</code>属性为<code>true</code>，如果为<code>false</code>，调用该方法没有任何效果。</p> <p>注意，该方法只是取消事件对当前元素的默认影响，不会阻止事件的传播。如果要阻止传播，可以使用<code>stopPropagation()</code>或<code>stopImmediatePropagation()</code>方法。</p> <h4 id="event-stoppropagation"><a href="#event-stoppropagation" class="header-anchor">#</a> Event.stopPropagation()</h4> <p><code>stopPropagation</code>方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上其他的事件监听函数。</p> <h4 id="event-composedpath"><a href="#event-composedpath" class="header-anchor">#</a> Event.composedPath()</h4> <p><code>Event.composedPath()</code>返回一个数组，成员是事件的最底层节点和依次冒泡经过的所有上层节点。</p> <h4 id="event-stopimmediatepropagation"><a href="#event-stopimmediatepropagation" class="header-anchor">#</a> Event.stopImmediatePropagation()</h4> <p><code>Event.stopImmediatePropagation</code>方法阻止同一个事件的其他监听函数被调用，不管监听函数定义在当前节点还是其他节点。也就是说，该方法阻止事件的传播，比<code>Event.stopPropagation()</code>更彻底。</p> <p>如果同一个节点对于同一个事件指定了多个监听函数，这些函数会根据添加的顺序依次调用。只要其中有一个监听函数调用了<code>Event.stopImmediatePropagation</code>方法，其他的监听函数就不会再执行了</p> <h2 id="customevent-接口"><a href="#customevent-接口" class="header-anchor">#</a> CustomEvent 接口</h2> <blockquote><p>CustomEvent 接口用于生成自定义的事件实例。那些浏览器预定义的事件，虽然可以手动生成，但是往往不能在事件上绑定数据。如果需要在触发事件的同时，传入指定的数据，就可以使用 CustomEvent 接口生成的自定义事件对象。</p> <p>浏览器原生提供<code>CustomEvent()</code>构造函数，用来生成 CustomEvent 事件实例。</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">new</span> <span class="token class-name">CustomEvent</span><span class="token punctuation">(</span>type<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//我们手动定义了build事件。该事件触发后，会被监听到，从而输出该事件实例的detail属性（即字符串hello）。</span>
<span class="token keyword">var</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomEvent</span><span class="token punctuation">(</span><span class="token string">'build'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token string">'detail'</span><span class="token operator">:</span> <span class="token string">'hello'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">eventHandler</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>detail<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'build'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>detail<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="事件种类"><a href="#事件种类" class="header-anchor">#</a> 事件种类</h2> <h3 id="鼠标事件（mouseevent）"><a href="#鼠标事件（mouseevent）" class="header-anchor">#</a> 鼠标事件（<code>MouseEvent</code>）</h3> <ul><li><code>click</code>：按下鼠标（通常是按下主按钮）时触发。</li> <li><code>dblclick</code>：在同一个元素上双击鼠标时触发。</li> <li><code>mousedown</code>：按下鼠标键时触发。</li> <li><code>mouseup</code>：释放按下的鼠标键时触发。</li> <li><code>mousemove</code>：当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会连续触发。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次。</li> <li><code>mouseenter</code>：鼠标进入一个节点时触发，进入子节点不会触发这个事件（详见后文）。</li> <li><code>mouseover</code>：鼠标进入一个节点时触发，进入子节点会再一次触发这个事件（详见后文）。</li> <li><code>mouseout</code>：鼠标离开一个节点时触发，离开父节点也会触发这个事件（详见后文）。</li> <li><code>mouseleave</code>：鼠标离开一个节点时触发，离开父节点不会触发这个事件（详见后文）。</li> <li><code>contextmenu</code>：按下鼠标右键时（上下文菜单出现前）触发，或者按下“上下文菜单键”时触发。</li> <li><code>wheel</code>：滚动鼠标的滚轮时触发，该事件继承的是<code>WheelEvent</code>接口。</li></ul> <p><code>click</code>事件指的是，用户在同一个位置先完成<code>mousedown</code>动作，再完成<code>mouseup</code>动作。因此，触发顺序是，<code>mousedown</code>首先触发，<code>mouseup</code>接着触发，<code>click</code>最后触发。</p> <p><code>dblclick</code>事件则会在<code>mousedown</code>、<code>mouseup</code>、<code>click</code>之后触发。</p> <p><code>mouseover</code>事件和<code>mouseenter</code>事件，都是鼠标进入一个节点时触发。两者的区别是，<code>mouseenter</code>事件只触发一次，而只要鼠标在节点内部移动，<code>mouseover</code>事件会在子节点上触发多次</p> <p>在父节点内部进入子节点，不会触发<code>mouseenter</code>事件，但是会触发<code>mouseover</code>事件。</p> <p><code>mouseout</code>事件和<code>mouseleave</code>事件，都是鼠标离开一个节点时触发。两者的区别是，在父元素内部离开一个子元素时，<code>mouseleave</code>事件不会触发，而<code>mouseout</code>事件会触发。</p> <p>在父节点内部离开子节点，不会触发<code>mouseleave</code>事件，但是会触发<code>mouseout</code>事件。</p> <h2 id="键盘事件"><a href="#键盘事件" class="header-anchor">#</a> 键盘事件</h2> <p>键盘事件由用户击打键盘触发，主要有<code>keydown</code>、<code>keypress</code>、<code>keyup</code>三个事件，它们都继承了<code>KeyboardEvent</code>接口。</p> <ul><li><code>keydown</code>：按下键盘时触发。</li> <li><code>keypress</code>：按下有值的键时触发，即按下 Ctrl、Alt、Shift、Meta 这样无值的键，这个事件不会触发。对于有值的键，按下时先触发<code>keydown</code>事件，再触发这个事件。</li> <li><code>keyup</code>：松开键盘时触发该事件。</li></ul> <p>如果用户一直按键不松开，就会连续触发键盘事件，触发的顺序如下。</p> <ol><li>keydown</li> <li>keypress</li> <li>keydown</li> <li>keypress</li> <li>…（重复以上过程）</li> <li>keyup</li></ol> <h2 id="拖拉事件"><a href="#拖拉事件" class="header-anchor">#</a> 拖拉事件</h2> <p>拖拉（drag）指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。</p> <p>拖拉的对象有好几种，包括元素节点、图片、链接、选中的文字等等。在网页中，除了元素节点默认不可以拖拉，其他（图片、链接、选中的文字）都是可以直接拖拉的。为了让元素节点可拖拉，可以将该节点的<code>draggable</code>属性设为<code>true</code>。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span>div draggable<span class="token operator">=</span><span class="token string">&quot;true&quot;</span><span class="token operator">&gt;</span>
  此区域可拖拉
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre></div><p><code>draggable</code>属性可用于任何元素节点，但是图片（<code>&lt;img&gt;</code>）和链接（<code>&lt;a&gt;</code>）不加这个属性，就可以拖拉。对于它们，用到这个属性的时候，往往是将其设为<code>false</code>，防止拖拉这两种元素。</p> <ul><li><code>drag</code>：拖拉过程中，在被拖拉的节点上持续触发（相隔几百毫秒）。</li> <li><code>dragstart</code>：用户开始拖拉时，在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。</li> <li><code>dragend</code>：拖拉结束时（释放鼠标键或按下 ESC 键）在被拖拉的节点上触发，该事件的<code>target</code>属性是被拖拉的节点。它与<code>dragstart</code>事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，<code>dragend</code>事件总是会触发的。</li> <li><code>dragenter</code>：拖拉进入当前节点时，在当前节点上触发一次，该事件的<code>target</code>属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。</li> <li><code>dragover</code>：拖拉到当前节点上方时，在当前节点上持续触发（相隔几百毫秒），该事件的<code>target</code>属性是当前节点。该事件与<code>dragenter</code>事件的区别是，<code>dragenter</code>事件在进入该节点时触发，然后只要没有离开这个节点，<code>dragover</code>事件会持续触发。</li> <li><code>dragleave</code>：拖拉操作离开当前节点范围时，在当前节点上触发，该事件的<code>target</code>属性是当前节点。如果要在视觉上显示拖拉离开操作当前节点，就在这个事件的监听函数中设置。</li> <li><code>drop</code>：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许<code>drop</code>，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下 ESC 键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。</li></ul> <p><strong>关于拖拉事件，有以下几个注意点</strong>。</p> <ul><li>拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发。</li> <li>将文件从操作系统拖拉进浏览器，不会触发<code>dragstart</code>和<code>dragend</code>事件。</li> <li><code>dragenter</code>和<code>dragover</code>事件的监听函数，用来取出拖拉的数据（即允许放下被拖拉的元素）。由于网页的大部分区域不适合作为放下拖拉元素的目标节点，所以这两个事件的默认设置为当前节点不允许接受被拖拉的元素。如果想要在目标节点上放下的数据，首先必须阻止这两个事件的默认行为。</li></ul> <h2 id="触摸操作"><a href="#触摸操作" class="header-anchor">#</a> 触摸操作</h2> <blockquote><p><code>Touch</code>接口的实例对象用来触摸点（一根手指或者一根触摸笔），包括位置、大小、形状、压力、目标元素等属性。有时，触摸动作由多个触摸点（多根手指）组成，多个触摸点的集合由<code>TouchList</code>接口的实例对象表示。<code>TouchEvent</code>接口的实例对象代表由触摸引发的事件，只有触摸屏才会引发这一类事件。</p> <p>很多时候，触摸事件和鼠标事件同时触发，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。如果想避免这种情况，可以用<code>event.preventDefault</code>方法阻止发出鼠标事件。</p></blockquote> <ul><li>Touch：一个触摸点</li> <li>TouchList：多个触摸点的集合</li> <li>TouchEvent：触摸引发的事件实例</li></ul> <h3 id="touch-接口"><a href="#touch-接口" class="header-anchor">#</a> Touch 接口</h3> <p>浏览器原生提供<code>Touch</code>构造函数，用来生成<code>Touch</code>实例。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> touch <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Touch</span><span class="token punctuation">(</span>touchOptions<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><code>identifier</code>：必需，类型为整数，表示触摸点的唯一 ID。</li> <li><code>target</code>：必需，类型为元素节点，表示触摸点开始时所在的网页元素。</li> <li><code>clientX</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的水平距离，默认为0。</li> <li><code>clientY</code>：可选，类型为数值，表示触摸点相对于浏览器窗口左上角的垂直距离，默认为0。</li> <li><code>screenX</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的水平距离，默认为0。</li> <li><code>screenY</code>：可选，类型为数值，表示触摸点相对于屏幕左上角的垂直距离，默认为0。</li> <li><code>pageX</code>：可选，类型为数值，表示触摸点相对于网页左上角的水平位置（即包括页面的滚动距离），默认为0。</li> <li><code>pageY</code>：可选，类型为数值，表示触摸点相对于网页左上角的垂直位置（即包括页面的滚动距离），默认为0。</li> <li><code>radiusX</code>：可选，类型为数值，表示触摸点周围受到影响的椭圆范围的 X 轴半径，默认为0。</li> <li><code>radiusY</code>：可选：类型为数值，表示触摸点周围受到影响的椭圆范围的 Y 轴半径，默认为0。</li> <li><code>rotationAngle</code>：可选，类型为数值，表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间，默认值为0。</li> <li><code>force</code>：可选，类型为数值，范围在<code>0</code>到<code>1</code>之间，表示触摸压力。<code>0</code>代表没有压力，<code>1</code>代表硬件所能识别的最大压力，默认为<code>0</code>。</li></ul> <h3 id="touchlist-接口"><a href="#touchlist-接口" class="header-anchor">#</a> TouchList 接口</h3> <p>它的实例属性和实例方法只有两个。</p> <ul><li><code>TouchList.length</code>：数值，表示成员数量（即触摸点的数量）。</li> <li><code>TouchList.item()</code>：返回指定位置的成员，它的参数是该成员的位置编号（从零开始）。</li></ul> <h3 id="touchevent-接口"><a href="#touchevent-接口" class="header-anchor">#</a> TouchEvent 接口</h3> <div class="language- extra-class"><pre class="language-text"><code>new TouchEvent(type, options)
</code></pre></div><ul><li><code>touches</code>：<code>TouchList</code>实例，代表所有的当前处于活跃状态的触摸点，默认值是一个空数组<code>[]</code>。</li> <li><code>targetTouches</code>：<code>TouchList</code>实例，代表所有处在触摸的目标元素节点内部、且仍然处于活动状态的触摸点，默认值是一个空数组<code>[]</code>。</li> <li><code>changedTouches</code>：<code>TouchList</code>实例，代表本次触摸事件的相关触摸点，默认值是一个空数组<code>[]</code>。</li> <li><code>ctrlKey</code>：布尔值，表示 Ctrl 键是否同时按下，默认值为<code>false</code>。</li> <li><code>shiftKey</code>：布尔值，表示 Shift 键是否同时按下，默认值为<code>false</code>。</li> <li><code>altKey</code>：布尔值，表示 Alt 键是否同时按下，默认值为<code>false</code>。</li> <li><code>metaKey</code>：布尔值，表示 Meta 键（或 Windows 键）是否同时按下，默认值为<code>false</code></li></ul> <h3 id="触摸事件的种类"><a href="#触摸事件的种类" class="header-anchor">#</a> 触摸事件的种类</h3> <ul><li><code>touchstart</code>：用户开始触摸时触发，它的<code>target</code>属性返回发生触摸的元素节点。</li> <li><code>touchend</code>：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的<code>target</code>属性与<code>touchstart</code>事件一致的，就是开始触摸时所在的元素节点。它的<code>changedTouches</code>属性返回一个<code>TouchList</code>实例，包含所有不再触摸的触摸点（即<code>Touch</code>实例对象）。</li> <li><code>touchmove</code>：用户移动触摸点时触发，它的<code>target</code>属性与<code>touchstart</code>事件一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。</li> <li><code>touchcancel</code>：触摸点取消时触发，比如在触摸区域跳出一个情态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏）、用户的触摸点太多，超过了支持的上限（自动取消早先的触摸点）。</li></ul> <h2 id="session-历史事件"><a href="#session-历史事件" class="header-anchor">#</a> session 历史事件</h2> <h3 id="pageshow-事件，pagehide-事件"><a href="#pageshow-事件，pagehide-事件" class="header-anchor">#</a> pageshow 事件，pagehide 事件</h3> <p>默认情况下，浏览器会在当前会话（session）缓存页面，当用户点击“前进/后退”按钮时，浏览器就会从缓存中加载页面。</p> <p>pageshow 事件在页面加载时触发，包括第一次加载和从缓存加载两种情况。如果要指定页面每次加载（不管是不是从浏览器缓存）时都运行的代码，可以放在这个事件的监听函数。</p> <p>第一次加载时，它的触发顺序排在<code>load</code>事件后面。从缓存加载时，<code>load</code>事件不会触发，因为网页在缓存中的样子通常是<code>load</code>事件的监听函数运行后的样子，所以不必重复执行。同理，如果是从缓存中加载页面，网页内初始化的 JavaScript 脚本（比如 DOMContentLoaded 事件的监听函数）也不会执行。</p> <p>pageshow 事件有一个<code>persisted</code>属性，返回一个布尔值。页面第一次加载时，这个属性是<code>false</code>；当页面从缓存加载时，这个属性是<code>true</code>。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'pageshow'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span>persisted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="popstate-事件"><a href="#popstate-事件" class="header-anchor">#</a> popstate 事件</h4> <p><code>popstate</code>事件在浏览器的<code>history</code>对象的当前记录发生显式切换时触发。注意，调用<code>history.pushState()</code>或<code>history.replaceState()</code>，并不会触发<code>popstate</code>事件。该事件只在用户在<code>history</code>记录之间显式切换时触发，比如鼠标点击“后退/前进”按钮，或者在脚本中调用<code>history.back()</code>、<code>history.forward()</code>、<code>history.go()</code>时触发。</p> <h4 id="hashchange-事件"><a href="#hashchange-事件" class="header-anchor">#</a> hashchange 事件</h4> <p><code>hashchange</code>事件在 URL 的 hash 部分（即<code>#</code>号后面的部分，包括<code>#</code>号）发生变化时触发。该事件一般在<code>window</code>对象上监听</p> <p><code>hashchange</code>的事件实例具有两个特有属性：<code>oldURL</code>属性和<code>newURL</code>属性，分别表示变化前后的完整 URL。</p> <h3 id="网页状态事件"><a href="#网页状态事件" class="header-anchor">#</a> 网页状态事件</h3> <h4 id="domcontentloaded-事件"><a href="#domcontentloaded-事件" class="header-anchor">#</a> DOMContentLoaded 事件</h4> <p>网页下载并解析完成以后，浏览器就会在<code>document</code>对象上触发 DOMContentLoaded 事件。这时，仅仅完成了网页的解析（整张页面的 DOM 生成了），所有外部资源（样式表、脚本、iframe 等等）可能还没有下载结束。也就是说，这个事件比<code>load</code>事件，发生时间早得多。</p> <h4 id="readystatechange-事件"><a href="#readystatechange-事件" class="header-anchor">#</a> readystatechange 事件</h4> <p><code>readystatechange</code>事件当 Document 对象和 XMLHttpRequest 对象的<code>readyState</code>属性发生变化时触发。<code>document.readyState</code>有三个可能的值：<code>loading</code>（网页正在加载）、<code>interactive</code>（网页已经解析完成，但是外部资源仍然处在加载状态）和<code>complete</code>（网页和所有外部资源已经结束加载，<code>load</code>事件即将触发）。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>document<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token string">'interactive'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="窗口事件"><a href="#窗口事件" class="header-anchor">#</a> 窗口事件</h3> <h3 id="resize-事件"><a href="#resize-事件" class="header-anchor">#</a> resize 事件</h3> <p><code>resize</code>事件在改变浏览器窗口大小时触发，主要发生在<code>window</code>对象上面。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">resizeMethod</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>body<span class="token punctuation">.</span>clientWidth <span class="token operator">&lt;</span> <span class="token number">768</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'移动设备的视口'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

window<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'resize'</span><span class="token punctuation">,</span> resizeMethod<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="fullscreenchange-事件，fullscreenerror-事件"><a href="#fullscreenchange-事件，fullscreenerror-事件" class="header-anchor">#</a> fullscreenchange 事件，fullscreenerror 事件</h3> <p><code>fullscreenchange</code>事件在进入或推出全屏状态时触发，该事件发生在<code>document</code>对象上面。</p> <div class="language- extra-class"><pre class="language-text"><code>document.addEventListener('fullscreenchange', function (event) {
  console.log(document.fullscreenElement);
});
</code></pre></div><h2 id="剪贴板事件"><a href="#剪贴板事件" class="header-anchor">#</a> 剪贴板事件</h2> <ul><li><code>cut</code>：将选中的内容从文档中移除，加入剪贴板时触发。</li> <li><code>copy</code>：进行复制动作时触发。</li> <li><code>paste</code>：剪贴板内容粘贴到文档后触发。</li></ul> <h2 id="焦点事件"><a href="#焦点事件" class="header-anchor">#</a> 焦点事件</h2> <ul><li><code>focus</code>：元素节点获得焦点后触发，该事件不会冒泡。</li> <li><code>blur</code>：元素节点失去焦点后触发，该事件不会冒泡。</li> <li><code>focusin</code>：元素节点将要获得焦点时触发，发生在<code>focus</code>事件之前。该事件会冒泡。</li> <li><code>focusout</code>：元素节点将要失去焦点时触发，发生在<code>blur</code>事件之前。该事件会冒泡。</li></ul> <p><strong>由于<code>focus</code>和<code>blur</code>事件不会冒泡，只能在捕获阶段触发，所以<code>addEventListener</code>方法的第三个参数需要设为<code>true</code>。</strong></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/vuepress/CheckList/Browser/dom.html" class="prev">
        Dom
      </a></span> <span class="next"><a href="/vuepress/CheckList/Browser/other.html">
        其他
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/vuepress/assets/js/app.0ad50b13.js" defer></script><script src="/vuepress/assets/js/2.7cf59c07.js" defer></script><script src="/vuepress/assets/js/18.e66fe3ad.js" defer></script>
  </body>
</html>
